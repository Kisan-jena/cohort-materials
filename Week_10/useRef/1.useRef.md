# useRef Hook in React

## Introduction

`useRef` is a React Hook that provides a way to persist values across renders without causing re-renders. It is primarily used to reference DOM elements directly and store mutable values that do not trigger re-renders when updated.

## Syntax

```jsx
const refContainer = useRef(initialValue);
```

- `initialValue`: The initial value of the `ref` object.
- `useRef` returns an object with a `current` property that can be assigned or accessed.

## Key Features

1. **Does not trigger re-renders**: Updating the `.current` property does not cause the component to re-render.
2. **References DOM elements**: Used to get a reference to a DOM node or React component.
3. **Holds mutable values**: Can store values without causing re-renders.
4. **Can persist previous values**: Useful for keeping track of state changes without affecting rendering.

## Comparison: `useRef` vs. `useState`

| Feature             | `useRef` | `useState` |
|--------------------|---------|------------|
| Triggers re-render? | No      | Yes        |
| Stores DOM references? | Yes  | No         |
| Updates persist across renders? | Yes | Yes |
| Suitable for UI updates? | No  | Yes |
| Ideal for storing previous values? | Yes | No (unless used with `useEffect`) |

### Example Comparison

#### Using `useRef`
```jsx
import React, { useRef } from 'react';

const RefExample = () => {
  const countRef = useRef(0);

  const increment = () => {
    countRef.current += 1;
    console.log(`Count: ${countRef.current}`);
  };

  return (
    <div>
      <p>Count (does not re-render): {countRef.current}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};

export default RefExample;
```

#### Using `useState`
```jsx
import React, { useState } from 'react';

const StateExample = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count (triggers re-render): {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};

export default StateExample;
```

## Basic Example: Referencing a DOM Element

```jsx
import React, { useRef, useEffect } from 'react';

const InputFocus = () => {
  const inputRef = useRef(null);

  useEffect(() => {
    inputRef.current.focus();
  }, []);

  return <input ref={inputRef} type="text" placeholder="Auto-focused input" />;
};

export default InputFocus;
```

## Storing Mutable Values without Re-renders

```jsx
import React, { useRef, useState } from 'react';

const Counter = () => {
  const count = useRef(0);
  const [, forceRender] = useState();

  const increment = () => {
    count.current += 1;
    console.log(`Count: ${count.current}`);
  };

  return (
    <div>
      <p>Count: {count.current}</p>
      <button onClick={increment}>Increment</button>
      <button onClick={() => forceRender({})}>Re-render</button>
    </div>
  );
};

export default Counter;
```

## Accessing Previous State

```jsx
import React, { useRef, useEffect, useState } from 'react';

const PreviousStateExample = () => {
  const [count, setCount] = useState(0);
  const prevCount = useRef(null);

  useEffect(() => {
    prevCount.current = count;
  }, [count]);

  return (
    <div>
      <p>Current count: {count}</p>
      <p>Previous count: {prevCount.current}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};

export default PreviousStateExample;
```

## Industrial Use Cases

### 1. Persisting Scroll Position

```jsx
import React, { useRef, useEffect } from 'react';

const ScrollTracker = () => {
  const scrollPosition = useRef(0);

  const handleScroll = () => {
    scrollPosition.current = window.scrollY;
    console.log(`Scroll Position: ${scrollPosition.current}`);
  };

  useEffect(() => {
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  return <div style={{ height: '200vh' }}>Scroll down to test</div>;
};

export default ScrollTracker;
```

### 2. Managing Focus in Forms

```jsx
import React, { useRef } from 'react';

const FormWithFocus = () => {
  const inputRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Submitted: ${inputRef.current.value}`);
    inputRef.current.focus();
  };

  return (
    <form onSubmit={handleSubmit}>
      <input ref={inputRef} type="text" placeholder="Enter text" />
      <button type="submit">Submit</button>
    </form>
  );
};

export default FormWithFocus;
```

### 3. Tracking API Call Timestamp

```jsx
import React, { useRef } from 'react';

const APICallTracker = () => {
  const lastCallTimestamp = useRef(null);

  const makeAPICall = () => {
    lastCallTimestamp.current = new Date().toISOString();
    console.log(`Last API Call: ${lastCallTimestamp.current}`);
  };

  return (
    <div>
      <button onClick={makeAPICall}>Make API Call</button>
    </div>
  );
};

export default APICallTracker;
```

### 4. Managing WebSocket Connections

```jsx
import React, { useRef, useEffect } from 'react';

const WebSocketComponent = () => {
  const socketRef = useRef(null);

  useEffect(() => {
    socketRef.current = new WebSocket('wss://example.com/socket');
    socketRef.current.onopen = () => console.log('Connected');
    return () => socketRef.current.close();
  }, []);

  return <p>WebSocket Connection Managed with useRef</p>;
};

export default WebSocketComponent;
```

## Conclusion

- `useRef` is a powerful hook for persisting values across renders.
- It is ideal for referencing DOM elements, storing mutable values, and managing external resources.
- It should not be used when reactivity is required; use `useState` instead.

By understanding and implementing these use cases, you can leverage `useRef` effectively in real-world applications.
